{
  "hash": "dbb76c054cca067e2ed37f28f5901e28",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Entropy - Identifying compressed files\"\nauthor: \"Nico\"\ndate: \"2024-11-10\"\ncategories: [math, code]\n---\n\n\n\nAbout Shannon's Information Entropy, applied to potentially detecting ciphered or compressed text compared to plain text.\n\n(First entry of the new platform, let's see how it goes.)\n\n## Shannon's Information Entropy\n\n### Why try to understand that?\n\nLong story short, Information Entropy is useful in quite a few Machine learning algorithms, and to name only a few, the following two use it directly:\n\n-   Partitioning Trees (for nodes selection)\n\n-   Logistic Regression (through log loss)\n\nDoesn't seem like much, said like that, but the Logistic Regression in turn can be used for... Neural Networks :)\n\n### How it is defined?\n\nThe best way I personally managed to try and understand information entropy is through the concept of compression and surprise.\n\nA few helpful descriptions:\n\n\"\\[...\\] the expected amount of information needed to describe the state of the variable \\[...\\]\"\n\n\"Entropy is the measure of uncertainty of a variable. The more uncertain it is, the higher the entropy is.\"\n\nHere is the mathematical expression of it:\n\n$$\nH(X) = - \\sum_{x \\in X} p(x) log(p(x))\n$$\n\nFrom the Wikipedia (I mean, why not?), this is the part that somehow can make sense for an intuitive understanding of the concept:\n\n\"The *information content,* also called the *surprisal* or *self-information,* of an event $E$ is a function which increases as the probability $p(E)$ of an event decreases. When $p(E)$ is close to 1, the surprisal of the event is low, but if $p(E)$ is close to 0, the surprisal of the event is high. This relationship is described by the function\n\n$$\nlog({1 \\over p(E)})\n$$\n\nwhere $log()$ is the logarithm, which gives 0 surprise when the probability of the event is 1. In fact, log is the only function that satisfies Ð° specific set of conditions \\[...\\]\"\n\n## Application: Detecting cipher/zip on data streams\n\nWe're aiming for this today:\n\n![Characters distribution in Plain/Zip text for some Wiki entries](sample_characters_prevalence_visu.png)\n\n### The code\n\nThe code will be on my Github soon enough (if not already).\n\nBut for now, a few blocks of it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_freq_df <- function(filename) {\n    test1 <- file(filename, open=\"rb\", raw = TRUE)\n    t1_bytes <- t1_chars <- c()\n    while(TRUE) {\n        temp <- readBin(test1, what = \"raw\")\n        if(length(temp) == 0) break;\n        t1_bytes <- c(t1_bytes, temp)\n        t1_chars <- c(t1_chars, rawToChar(temp))\n    }\n    \n    t1_df <- data.frame(sort(table(as.character.hexmode(t1_bytes)), decreasing = TRUE))\n    t1_df$char <- names(sort(table(t1_chars), decreasing = TRUE))\n    t1_df$probs <- as.numeric(prop.table(sort(table(t1_chars), decreasing = TRUE)))\n    names(t1_df) <- c(\"x\", \"y\", \"char\", \"probs\")\n    # print(sum(t1_df$y))\n    t1_df$y <- t1_df$y/sum(t1_df$y) \n    t1_df\n}\n```\n:::\n\n\n\nThe above function is a (bad, but functional) way of taking a file, reading it in \"raw\" format, and output byte-by-byte into a dataframe.\n\n-   The first output column will be the \"raw byte\" (for text, the ASCII code, say \"20\" for space character).\n\n-   The second column contains the Probability of appearance of a character, compared to the whole text being analysed (so, the frequency of it's appearance).\n\n-   The third column is for reference only, to \"see\" what the character would look like in plain text. Note that \" \" (space) and null would look similar... And so would other encoded bytes, but that's not to worry for today.\n\nWith the above in mind, here is an output of plain and zip'ed text, along with the Shannon's Entropy of it, correspondingly:\n\n\n\n\n```{.r .cell-code}\n> firewall_wiki <- compare_clear_zip(1, wiki_pages_df)\n   x          y char      probs\n1 20 0.14766670      0.14766670\n2 65 0.09267745    e 0.09267745\n3 69 0.07790143    i 0.07790143\n4 74 0.06658562    t 0.06658562\n5 6e 0.06621154    n 0.06621154\n6 61 0.06050687    a 0.06050687\n   x           y char       probs\n1  0 0.012244898      0.012244898\n2 39 0.006722689    9 0.006722689\n3 72 0.006722689    r 0.006722689\n4 5f 0.006482593    _ 0.006482593\n5 34 0.006242497    4 0.006242497\n6 e4 0.006242497 \\xe4 0.006242497\n[1] \"Entropy Plain text: 4.38674335811205\"\n[1] \"Entropy Zip text: 7.9669387921095\"\n```\n\n\n\n-   In Plain text, the space character appears quite a bit. So do the letters e, i, t, n, a... (That's for English, and remember these are small sample texts extracted from some Wikipedia pages...). Plain text has repetition on some characters (higher probability of appearance), with varying distributions (and uses fewer different bytes).\n\n-   In Zip, the probabilities are each MUCH lower, and more even across all possible bytes. And that's our KEY concept for today. Zip is **compression**, so **all** its characters have as few repetition as possible (i.e. low probability).\n\n-   Interestingly, with the above approache, **ciphered data would look like zip data**.\n\nOK, so let's go back to our definitions of the first part:\n\n\"\\[...\\] When $p(E)$ is close to 1, the surprisal of the event is low, but if $p(E)$ is close to 0, the surprisal of the event is high\\[...\\]\"\n\nHopefully we're getting somewhere with understanding the concept. Uncommon characters will have higher \"surprisal\", and lower probability of appearing.\n\nOh: And we should not be afraid of the math, it wasn't that bad.\n\n### What does it mean in practice?\n\nWell, it means that if you **sample some** bytes sniffed on a network, if you see seemingly random characters with no prevalence of a few ones, you know it's not clear-text.\n\nAnd yes, if you have the file extension, maybe this is all useless.\n\nSo why you would care? First, this is pretty cool. If you sample data (from a network stream, or bytes on a disk...), you can distinguish \"automagically\" what's plain text and what's ciphered/zip.\n\nMaybe you can use that to detect covert channels out of packet capture?\n\nOr maybe let your computer on its own decide to use one set of algorithm to analyse things when there is plain text, and use **another** set of characters when there is ciphered/compressed text (or images, etc.).\n\n## Conclusions\n\nAll this took me quite a while to really understand it. Or think I do, anyway :D\n\nToday we've tried to explain the concept of information entropy through a simple application. If at this point my readers have gotten somewhat of an intuition about the concept, I'll be very happy.\n\nAnd the concept is quite relevant for Machine Learning, as we shall see in future posts.\n\n## References\n\n<https://en.wikipedia.org/wiki/Entropy_(information_theory)>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}