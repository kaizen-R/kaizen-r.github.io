<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nico">
<meta name="dcterms.date" content="2024-10-26">

<title>ML Concepts: Unsupervised Learning – Clustering – DBScan – Kaizen-R.com new home</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Kaizen-R.com new home</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">ML Concepts: Unsupervised Learning – Clustering – DBScan</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">ML</div>
                <div class="quarto-category">visualization</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Nico </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 26, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section"></h2>
<p>So as I keep working on an upcoming presentation I shall give in a few weeks, I thought I’d prepare something a bit more “live” than just a PPT with Memes (although who doesn’t like a few Memes in a PPT?).<br>
My current idea is to talk about some “Machine Learning Key Concepts”, and then bring it back to Cybersecurity applications.</p>
<p>So part of it could be about two key things:</p>
<ul>
<li><p>Supervised vs Unsupervised Learning</p></li>
<li><p>Symbolic vs Sub-Symbolic “AI”</p></li>
</ul>
<p>Which I feel help frame a bit what we’re talking about when we talk about Machine Learning.</p>
<p>Today, we’ll do some review, and then talk about Clustering. Here an output of one such algorithm, in 3D:</p>
</section>
<section id="simplified-definition-of-machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="simplified-definition-of-machine-learning">Simplified definition of Machine Learning</h2>
<p>Now I’m probably NOT the right source for you to learn this, so I really suggest you read about that somewhere else. The <a href="https://en.wikipedia.org/wiki/Machine_learning">wiki</a> puts it a bit like so:</p>
<p><em>“The study of statistical algorithms&nbsp;that can learn from&nbsp;data&nbsp;and&nbsp;generalize&nbsp;to unseen data, and thus perform&nbsp;tasks&nbsp;without explicit&nbsp;instructions.”</em></p>
<p>There are quite a FEW THINGS in that sentence right there. But for today:</p>
<ol type="1">
<li><p>In traditional programming, a person WRITES A PROGRAM, that receives INPUT (say a picture), and generates an OUTPUT (say… “Dog” or “Cat”)</p></li>
<li><p>In a Machine Learning approach, a person PROVIDES (LOTS OF) INPUTS AND CORRESPONDING OUTPUTS, and the COMPUTER CREATES THE PROGRAM (usually then called a “model”).</p></li>
</ol>
<p>The above is specifically applicable to “Supervised” learning, but nevermind that, the key here is: The computer CREATES the MODEL that we (humans) can then apply to new data.</p>
</section>
<section id="why-unsupervised-learning" class="level2">
<h2 class="anchored" data-anchor-id="why-unsupervised-learning">Why Unsupervised Learning?</h2>
<p>In Cybersecurity, a relevant part of the job for ML can be about detecting anomalies.</p>
<p>Often times, you don’t get pre-trained neural networks applicable to your scenario. Or more simple: you don’t have access to relevant “big data” (which would help with training your models, indeed), i.e.&nbsp;people (companies) rarely share detailed data (network packets, logs, configurations, etc.) of their breaches. Understandable.</p>
<p>And so “unsupervised” learning might make sense in that scenario. Unsupervised Learning is about discovering structure in your data, that you might not have known about upfront.</p>
</section>
<section id="warning" class="level2">
<h2 class="anchored" data-anchor-id="warning">Warning</h2>
<p>Also there are lots of potential issues with leveraging ML, but two possibly relevant ones would be:</p>
<ul>
<li><p><strong>Imbalance between classes</strong> (hopefully you have little data as examples of real attacks on your network, and a LOT of “normal traffic” data, for instance),</p></li>
<li><p>Base-rate fallacy (a SOC analyst might, in certain settings, work most of their time on false-positives)</p></li>
</ul>
<p>That said, let’s keep it simple for today, we will keep it clean, no complications (yet, anyway).</p>
</section>
<section id="symbolic-vs-sub-symbolic" class="level2">
<h2 class="anchored" data-anchor-id="symbolic-vs-sub-symbolic">Symbolic vs Sub-symbolic</h2>
<p>Simplifying A LOT, let’s just say for today that “Symbolic” can be read by a Human, and so it <em>could</em> look like sets of rules of the type:</p>
<p><em>IF (A &amp; NOT B) THEN (ACTION X)</em></p>
<p>Where a person could read A (“number of Errors in 1′ log file &gt; 100”), B (“less than 10 errors are of type ‘login failed’”), X (“Block originating IP on Firewall”). (Note the negation of B in the expression above ;))</p>
<p>Putting together many of these rules a person COULD setup a reactive security configuration for a firewall based on monitoring logs. I mean, conceptually, why not?! That would be an “Expert System”, as they called them in the 80’s.</p>
<p><em>Oh: And you COULD have “Machine Learning” on top of Rule-based systems. For example one interesting field (to me) that somehow has received little attention so far is that of the “Learning Classifier Systems” (LCS)… But that’s for another day.</em></p>
<p><strong>When you enter the realm of Neural Networks</strong>, Dimensionality Reduction (say PCA on TF-IDF), BackPropagation, non-linearity, differentiable functions, etc., <strong>you quickly leave the realm of “human readable”, and you enter the world of vectors, matrices, tensors…</strong>&nbsp;In these settings, you use numbers, linear algebra, and the <strong>concept of distance</strong>.</p>
<p>For instance, <strong>distances between the “calculated class” and “real class”</strong> for a set of entries (say, images of cats and dogs, or log files, or…), <strong>trying to reduce these distances would mean trying to reduce the prediction error</strong>. Said like that, it is probably a bit confusing. But to be perfectly clear: <em>That last sentence is a BIG part of what supervised machine learning with Neural Networks is all about!</em> (More exactly in this case the goal is to minimize the difference between predicted and real class, or predicted and real value)</p>
<p>Let’s just make a note at this point, then: <strong>Sub-symbolic</strong> is the domain of neural networks, a world of algebra and calculus, weights and thresholds, which often are hard to translate into “human-readable rules”. And more specifically in the case of the current trend with <strong>deep neural networks</strong> (which are truly an impressive thing!), it’s a big issue, because <strong>there is a problem with how we can UNDERSTAND what the algorithm does</strong>. And that introduces things <strong>like lack of trust, issues with responsibility</strong>, and not being able to explain why something works (or, usually more to the point, <strong>why something suddenly DOES NOT work</strong>).</p>
<p>But the goal here and today is not to explain the details (“why backpropagation expects differentiable activation functions, for gradient descent, and the Chain Rule” – or “why ReLU works so good for training a NNet, but it’s not a differentiable function, and so people use approximations like leaky ReLU”… All that might be a bit much – Me at least, I still often need to come back to my books each time I want to explain these things correctly… So some other time :D).</p>
<p>Today I’ll focus on the <strong>concept of distance between points</strong>, and leverage that to identify “clusters” of points (and we’ll mention multi-dimensional spaces real quick).</p>
</section>
<section id="clustering" class="level2">
<h2 class="anchored" data-anchor-id="clustering">Clustering</h2>
<p>One type of “Unsupervised Learning” is what is called clustering. The main idea is to look at data and to try and create “groups of similar data points”. That’s it. That’s what Clustering is all about.</p>
<p>Right, but… How?</p>
<p>So let’s see:</p>
<p>If a = 20, b = 21, c = 99 and d = 100… Would you agree you could possibly say “a is nearer from b than from d”. And iterating, you might conclude:</p>
<ul>
<li><p>Group 1: a, b</p></li>
<li><p>Group 2: c, d</p></li>
</ul>
<p>Does that make sense? Hopefully YES 🙂</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/1d_groups-1024x116.png" class="img-fluid figure-img"></p>
<figcaption>1d and 3 groups of points</figcaption>
</figure>
</div>
<p>Let’s move on to two dimensions. You get a set of points (imagine, for Cybersecurity, I don’t know: for each point representing a machine on a network, the x coordinate represents the number of TCP Packets sent by the machine from its TCP Port 80 in the last minute, and the y coordinate represents the number of TCP Packets sent by the same machine from its port TCP 443 in the last minute).</p>
<p>So now you might have two sets of points that “cluster together”, some with very little activity on both axis, that is: (x, y) = 0, and others (maybe only a few), that have a range of numbers but overall have maybe lots of activity as per both axis, so say for example (x &gt; 1000, y &gt; 1000).</p>
<p>Let’s apply the same logic as above. There will probably be two clusters, one of which might have many points but overlapping, and the other a cloud of points on the top right… Representing Web Servers.</p>
<p>That’s probably a very dumb example, but it serves a purpose: You COULD identify groups of machines in these two dimensions. Distances here would probably use <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean Distance</a>, but if you understand it visually, good enough for today.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/2d_groups-300x234.png" class="img-fluid figure-img"></p>
<figcaption>2d and 2 groups of points</figcaption>
</figure>
</div>
<p>And with more (very similar) dimensions, you might be able to discover groups of machines that are similar to one another, but a bit different from those of another group…</p>
<p>Here, <strong>I just gave you an algorithm to group machines</strong> and <em>separate Windows from Linux, or Clients from Servers, or Web from Mail from LDAP from NTP from DNS servers</em>… Obviously, the above categories are a bit… not great, well because most of the time you will KNOW what the machines are to begin with. <strong>But what if all you have to work from is a tcpdump file?</strong></p>
<p>Let’s visualize this, shall we?</p>
</section>
<section id="dbscan" class="level2">
<h2 class="anchored" data-anchor-id="dbscan">DBScan</h2>
<p>One (of MANY) algorithms out there to do clustering is <a href="https://en.wikipedia.org/wiki/DBSCAN">DBScan</a>. Its very name says most of it: “Density based Spatial Clustering”.</p>
<p>I’m not going to reinvent the wheel today, and we’ll go right ahead and leverage the dbscan R package and its documentation. The <a href="https://github.com/kaizen-R/R/blob/master/Sample/AnomalyDetection/dbscan_demo_v001.R">code is here</a>.</p>
<p>So first, we’ll generate a set of seemingly almost-random points in a 2-dimensional space.</p>
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/Random_Points-300x194.png" class="img-fluid" alt=""></p>
<p>Visually, a person can already tell there seems to be some structure in there, some groups. How many might be a bit of a judgement call, but still.</p>
<p>Leveraging a number of neighbours (say, 4 nearest points to identify a group)&nbsp; to identify an “elbow” of the separation of the groups, we can set a “noise threshold” to the above whereby if a node is too removed from a group, it could be considered as SEPARATE.</p>
<p>Let’s see:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/Random_Points_Noise_Threshold-300x175.png" class="img-fluid figure-img"></p>
<figcaption>identifying noise in clustering</figcaption>
</figure>
</div>
<p>In the above, there is a “clear” change in trend in the line that finds said distances, at 0.85 approximately (red line) that identifies regions of LOW DENSITY of points, that the DBScan algorithm would then propose as a limit to separate OUTLIERS from the rest of clustered points.</p>
<p>It’s a bit of a mess to write down, but hopefully the results are self explanatory:</p>
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/Random_Points_Proposed_Clusters-300x195.png" class="img-fluid" alt=""></p>
<p>Here we color the groups of points by cluster, or what the algorithm has proposed as such. Again, the only concept in use was the distance to other points. A detailed look in the last picture would show that maybe something is amiss, at least one point had x &lt; 0 before, and it doesn’t show up here.<br>
That’s an identified outlier.</p>
<hr>
<p><strong>Let’s take a minute here:</strong> We’ve identified stuff that goes together, so “clusters”.</p>
<p>But one <strong>key</strong> aspect (value) of DBScan over some alternative algorithms for clustering is, <strong>it can help with ANOMALY DETECTION.</strong> Indeed, that’s why I have chosen this algorithm today (the typical intro to clustering would have probably focused on KMeans first :D).</p>
<p>So now, we have an “automated ML algorithm” that receives coordinates of points, and is <strong>capable of identifying groups of points, AND points that seem to not quite fit anywhere</strong>.</p>
<p><strong>Remember earlier when we mentioned “imbalance” of prevalence of “normal traffic” vs “attack traffic” on a corporate network? Well, this is why I mentioned it.</strong> With a little luck, what a DBScan output tells us are “outliers” is something that is <strong>UNUSUAL</strong>, and <strong>HOPEFULLY that’s actually identifying attack-related data for us!</strong></p>
<p>OK, back to the demos.</p>
<hr>
</section>
<section id="why-bother" class="level2">
<h2 class="anchored" data-anchor-id="why-bother">Why bother?</h2>
<p>OK, so beyond finding things out about your data, the data you have… <strong>What if you could get information from new data</strong> (of the same kind, that is)?</p>
<p>After all, you’ve identified groups. And that’s cool, and maybe you’ve learned that somehow ten computers seem to behave similarly, and quite differently from another set of 50 computers, on the same network. And maybe that leads you to do some digging and conclude that all 10 of the first group were DB servers, and the other were front-end stuff (Idk, Apache). All from network dump files. Not too bad.</p>
<p>But now you receive a new dump file, which you’re told contains network traces from other computers. Wouldn’t it be cool to then just feed that to your “trained” model (which, remember, was actually unsupervised to begin with), and get it to tell you – <em>like a supervised</em> algorithm would: That new machine is a “Group 1” machine (and so you can deduce it’s a DB server).</p>
<p><em>I know, I know. Just look at ports, and you would know, fair enough</em>. Plus, it’s not clear the example above would even work (there are MANY considerations in there). Anyhow, let’s take your “pre-trained” model from above, and see what would happen with say 12 new points:</p>
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/Random_Points_New_Data-1024x709.png" class="img-fluid" alt=""> That’s it: New data, and without you having to look at it, the machine will tell you to which group each entry belongs. <strong>That’s the cool thing about Machine Learning 🙂</strong></p>
</section>
<section id="going-3d" class="level2">
<h2 class="anchored" data-anchor-id="going-3d">Going 3D</h2>
<p>An almost identical exercise, but in 3 Dimensions. I just want to show it so that we can all agree on one thing: We human can conceptualize up to three dimensions. But with this next visualization, I hope to show <strong>one important idea</strong>: There is <strong>nothing precluding an algorithm from going and work into “higher dimensions”</strong>. We can easily visualize groups in 1-D, 2-D, now 3-D (maybe, on a screen, with the help of some animation). But 4-D, or 1000-D, is NOT a problem for a computer!</p>
<p>OK, so in 3D, same algorithm, similarly random-generated data points. What DBScan can do is shown at the top of this Blog post 🙂</p>
<p>(I just know people are more impressed by 3-D animations than 2D visuals for some reason, and so I put it at the top to keep you interested :D)&nbsp;</p>
</section>
<section id="its-not-magic" class="level2">
<h2 class="anchored" data-anchor-id="its-not-magic">It’s NOT magic</h2>
<p>Let’s see a very classical example, and how DBScan <strong>kinda’ fails</strong>. Not really, but still.</p>
<p>When applied to the “Iris” dataset (if you’ve ever studied a bit of data science, you know what it is), DBScan identifies <strong>two clusters</strong>, while we all know there are <strong>3 types of flowers represented in the dataset</strong>.</p>
<p>That does NOT mean that DBScan FAILED. It just means that the information <em><strong>it</strong> can tell us about that dataset is that <strong>one</strong> group of flowers is clearly different from the <strong>rest</strong></em>. And that’s OK, although we know it’s insufficient. BUT YOU NEED TO KNOW IT’S NOT MAGIC. From a few data points / coordinates, it’s still only working with so much information…</p>
<p>Real groups: 3</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/Iris_Real_Classes-300x211.png" class="img-fluid figure-img"></p>
<figcaption>real iris groups</figcaption>
</figure>
</div>
<p>DBScan (with selected parameters)groups: 2 (and a few outlier points)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://www.kaizen-r.com/wp-content/uploads/2024/10/Iris_Proposed_Clusters-300x211.png" class="img-fluid figure-img"></p>
<figcaption>dbscan identified iris groups</figcaption>
</figure>
</div>
</section>
<section id="warning-2" class="level2">
<h2 class="anchored" data-anchor-id="warning-2">Warning 2</h2>
<p>NOT ALL numbers are ordinals/cardinals. Although 20, 21, 22, 23 might seem nearer from one another than say from 80, 123, or 443… That doesn’t mean you can use THAT “distance”.</p>
<p>In Cybersecurity (but in any other field), <strong>PLEASE remember DOMAIN KNOWLEDGE can “make or break”</strong> a data scientist. And not knowing why things don’t work as you expect then is a bad thing. And it’s <strong>not always the algorithm fault</strong>.</p>
<p>Web is different from NTP, while HTTPS uses cryptography and so does SSH, but… In context, port TCP 80 is NOT nearer TCP port 22 than it is from TCP Port 443.</p>
<p>You’ve been warned.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>Unsupervised Machine Learning has potential for applications to Cybersecurity data. Maybe used on network traffic captures or logs, one can identify structure and propose groupings of machines, users (by their activity, accesses, hours, who knows…).</p>
<p>Although we’ve seen one algorithm and how to visualize its decisions with 2- and 3-dimensional data, the “sky is the limit”, and if one can come up with 100 (or 1000) such dimensions (that’s the concept behind “feature engineering”), there is nothing precluding our machines to work with that and propose groupings for us (although not all algorithms deal nicely with “curse of dimensionality”, but that’s a different topic). In ML, more (quality) data is often a good thing. Also, if one of the 100 dimensions helps us separate perfectly some groups, some ML algorithm will find that and use it for us. Would you visualize manually and study 100 dimensions? 1000?</p>
<p>And that’s where it’s powerful: A person might have a hard time grouping hundreds of machines or users while considering <em>several</em> aspects at once, much less when the number of groups or “kinds of groups” to be found are not known upfront… But that’d be no issue for a computer 🙂</p>
<p>Hopefully I can walk some of my colleagues through the above concepts (organised in a PPT) and show them (in R :P) how all the concepts “work”, and then translate into “real world applications”.</p>
<p>Maybe next week I’ll move on to making text into multi-dimensional data points. And then, we’d be set to apply all the above to text data. Which is quite prevalent in Cybersecurity (CVE descriptions, logs, code… it’s all text :D).</p>
<section id="resources" class="level3">
<h3 class="anchored" data-anchor-id="resources">Resources</h3>
<p>Wikipedia as linked above, and dbscan R Package documentation, mostly.</p>
<p><a href="http://www.sthda.com/english/wiki/a-complete-guide-to-3d-visualization-device-system-in-r-r-software-and-data-visualization">Also this about making a video from 3D scatter plot with RGL</a></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>