<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nico">
<meta name="dcterms.date" content="2024-12-29">

<title>RLCS Day 4.5 - Fully Functional v0 and New Tests – Kaizen-R.com new home</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Kaizen-R.com new home</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kaizen-R"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">RLCS Day 4.5 - Fully Functional v0 and New Tests</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">ML</div>
                <div class="quarto-category">RLCS</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Nico </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 29, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="big-update-today" class="level1">
<h1>Big update today</h1>
<section id="intro-imperfect-but-very-cool" class="level2">
<h2 class="anchored" data-anchor-id="intro-imperfect-but-very-cool">Intro: Imperfect but very cool</h2>
<p>Version “0” is done and <strong>working</strong>. And I will say this, it is <strong>already showing some of its power</strong>. Let me show you.</p>
</section>
<section id="whats-in-it" class="level2">
<h2 class="anchored" data-anchor-id="whats-in-it">What’s in it</h2>
<p>Alright so this is what I have so far:</p>
<ul>
<li><p>A basic, fully functional, <strong>Michigan-style LCS for Supervised Learning</strong></p></li>
<li><p>A wrapper makes it easier to call the thing for training</p></li>
<li><p><strong>GA</strong> (tournament-based parents selection, one-point cross over reproduction, simple mutation) and <strong>Covering</strong> for rules discovery</p></li>
<li><p><strong>Deletion</strong> was somewhat fixed</p></li>
<li><p>Accuracy and other <strong>stats</strong> work</p></li>
<li><p>Printing support functions</p></li>
<li><p><strong>New</strong>: It includes <strong>subsumption</strong>. But calling <strong>subsumption affects performance</strong> – both ways – depending on the when/where/how, a known fact. But when used – and that’s an important running decision, by the way –, it condensates the relevant information encoded in the system… Making it, when applicable, much better!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="effects_of_subsumption_deletion.jpg" class="img-fluid figure-img"></p>
<figcaption>subsumption and deletion are costly, but effective to contain the size of the system</figcaption>
</figure>
</div></li>
<li><p><strong>New too: Testing</strong> can be called now too, which is very helpful to validate the value of the LCS</p></li>
<li><p>This LCS for SL accepts an environment that, importantly, currently supports <strong>only</strong>:</p>
<ul>
<li><p>Binary classes/actions (so 0 or 1)</p></li>
<li><p>Binary strings as input/states (no more no less) (and I mean, strings)</p></li>
<li><p>All states must be of equal length (whatever that is)</p></li>
</ul></li>
</ul>
<p>That’s on the plus side. On the not-so-great, well:</p>
<ul>
<li><p>Little-to-no error control in there yet</p></li>
<li><p>Next-to-zero documentation so far</p></li>
<li><p>And I’ll make a note on performance later in this post.</p></li>
<li><p>Imperfect/still-a-bit-disorganized code is probably an understatement.</p></li>
</ul>
<p>But that’s just what needs to happen next, I guess. <strong>Now on to what you can do with this thing.</strong></p>
</section>
<section id="test-1-not-bit-4" class="level2">
<h2 class="anchored" data-anchor-id="test-1-not-bit-4">Test 1: Not bit 4</h2>
<p>So I’ve already shown that one, but it wasn’t “perfect”. Here the new version and a few tricks allow me to show <strong>how the LCS can be used for data mining</strong>.</p>
<p>So I give it 70% of the sample space, and it comes up with the following “Classifiers Set”:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="not_bit_4_perfect_classifiers_set.jpg" class="img-fluid figure-img"></p>
<figcaption>Using LCS to discover the hidden rules in the dataset</figcaption>
</figure>
</div>
<p>Notice how this is quite exactly what the LCS was supposed to try and discover. And also how it indeed tells us what that particular “environment” (dataset and its classes) is all about.</p>
<p>(Oh, and in this particular exercise, I really did <strong>not</strong> need to run so many epochs, it’s just my default hyperparameter setting, but after a hundred or so epochs, it was already done.)</p>
<p>Let’s move to a <strong>more interesting example</strong>.</p>
</section>
<section id="test-2-mux6" class="level2">
<h2 class="anchored" data-anchor-id="test-2-mux6">Test 2: Mux6</h2>
<p>The “Introduction to Learning Classifier Systems” book – <a href="https://kaizen-r.github.io/posts/2024-12-08_A_new_project/">referenced in my first post on LCS</a> – explains the algorithm with (among much more explanations) one particular example, called a “6-bit multiplexer”.</p>
<p>The rules of that particular example are like so:</p>
<ul>
<li><p>you get a string of 6 bits as input</p></li>
<li><p>the first two bits point to an address in the resting 4 bits</p></li>
<li><p>the “class” of your classifier should be whatever the bit is at the designated address.</p></li>
</ul>
<p>A couple of examples:</p>
<ul>
<li><p>“010000” says “Bit 2 of the last 4 bits is the class, so 0”</p></li>
<li><p>“110001” says “Bit 4 of the last 4 bits is the class, so 1”</p></li>
<li><p>“101101” says “Bit 3 of the last 4 bits is the class, so 0”</p></li>
<li><p>…</p></li>
</ul>
<p>You get the idea. One aspect of this is meant to show that the LCS SL can somehow recognize <strong>things that are interrelated in the data</strong>, here how <strong>two different parts interact</strong>. They call this “epistasis”. For now, suffice to say, it’s a bit more interesting use-case and we hope our LCS can discover relevant rules.</p>
<p>Again, with 70% of the whole dataset (64 entries total, for 6 bits), we train our LCS and hope to identify important rules (ideally, up to <em>8 perfect rules</em> in this case – but that’s not guaranteed). Here I show one such trained Classifier Set (aka “LCS” or “Learning Classifier System”, where the S stands for “System”, implying more than one classifier working together… but I digress) that <strong>gets it almost perfect</strong>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mux6_almost_perfect_LCS.jpg" class="img-fluid figure-img"></p>
<figcaption>Almost perfect MUX6 LCS</figcaption>
</figure>
</div>
<p>You have to look somewhat carefully but you should find 7 of the 8 “perfect” classifiers in there. And I haven’t checked for this particular example, but if the training set (randomly selected) did contain all the needed cases (probably did), this LCS should also almost cover for the missing classifier (11###0 0). Hint, the following would be the only one that would match for that missing classifier, so they would participate to recommend the action/class, and see how they all recommend class 0 (…):</p>
<ul>
<li><p>1####0 0</p></li>
<li><p>#1#0#0 0</p></li>
<li><p>##00#0 0</p></li>
<li><p>##0#10 0</p></li>
</ul>
<p>So in spite of missing one perfect rule (and that’s also depending on the random environment and non-deterministic nature of the LCS training…), it would work in all testing cases.</p>
<p>Let’s move on to a (much) harder use-case.</p>
</section>
<section id="test-3-mnist-with-tricks" class="level2">
<h2 class="anchored" data-anchor-id="test-3-mnist-with-tricks">Test 3: MNIST!!! (with tricks)</h2>
<p>Now this was a stretch. the MNIST dataset is nothing like the dummy tests above, for sure. First, I don’t know how to manually write a perfect program manually for it (the above cases were trivial, comparatively).</p>
<p>Second, many trained neural nets on the MNIST dataset don’t get perfect record (but that’s understandable, if you spend enough time with that dataset).</p>
<p>Third, and quite important, the “states” here are numerical strings representing the shade (black-white) of 784 pixels (28*28) integers between 0 and 255. With a simple binary transformation I could end up with my states represented <strong>each</strong> <strong>as 6272 binary strings</strong> (8 bits per pixel).</p>
<p>And there are a few <em>thousand</em> entries (samples) per represented number.</p>
<p>I knew upfront, doing thousands of exposures per sample to get anywhere would take <strong>forever</strong>.</p>
<p>Fair enough, and so <strong>I simplified the problem first</strong>. Here is what I did:</p>
<ul>
<li><p>Compress the data, <strong>from shades to 0-1 values per pixel</strong>. I used a threshold to “sharpen” the dataset, so only if the value was &gt; 100 (out of 255) I would set my new pixel to 1, otherwise I set it to 0.</p></li>
<li><p>Compress further, <strong>from 28*28 to 7*7 pixels</strong>. Each original 4-pixels-square is encoded as only 1 pixel, with value <strong>1 if any of the 4*4 subsquare was one, 0 otherwise</strong>.</p></li>
<li><p>The above gives me <strong>7*7 binary strings, so my states are now 49 bits long</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mnist_compression_for_lcs.jpg" class="img-fluid figure-img"></p>
<figcaption>I “compress” the MNIST data before training my LCS</figcaption>
</figure>
</div></li>
<li><p>Class stays the same, but I also will do <strong>a simpler exercise</strong>. My LCS should <strong>distinguish between classes 0 and 1 only</strong>. (This is not an issue, it’s a choice. I just choose to keep things simple, that’s all, but the value of the approach is the same, think of it as a one-versus-rest approach if you want). This is in part to make things faster, and in (big) part because the code so far only allows two-classes-output only.</p></li>
</ul>
<p>Let me <strong>skip directly to the results here</strong>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mnist_0_1_results_example.jpg" class="img-fluid figure-img"></p>
<figcaption>Showing a couple of runs of an LCS SL on MNIST simplified dataset</figcaption>
</figure>
</div>
<p><em>(BTW, I meant to write “confusion matrix”, not “contention table” above, obviously… Apologies, I hadn’t slept much yesterday…)</em></p>
<p>I just want to <strong>make this clear</strong>:</p>
<ul>
<li><p>Training on a <strong>total 500 random (sampled) training inputs</strong> only (that’s the size of my <em>environment</em> here), so <em>roughly</em> 250 examples of pictures of Zero and 250 of One</p></li>
<li><p>Training on these 500 examples takes me <strong>between 7.4 and 9.3 minutes</strong> (in the above example)</p></li>
<li><p>It generalizes very well: I end up with an LCS that <strong>correctly classified 96 to 97+% of the 3799 sample tests</strong>.</p></li>
</ul>
<section id="edit-small-changes-good-perf-gains" class="level3">
<h3 class="anchored" data-anchor-id="edit-small-changes-good-perf-gains">EDIT: Small changes, good perf gains</h3>
<p>Just FYI, I worked a bit more (31/12) on this and reduced the running times for <strong>better results</strong> in just above <strong>20 seconds</strong> for the mono-thread version:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="perf_update_20241231.jpg" class="img-fluid figure-img"></p>
<figcaption>Better speed AND accuracy after slight code update</figcaption>
</figure>
</div>
<p>This gives us in fact <strong>98.6+% of correctly classified test samples after 20s training</strong> (still on only 500 training samples)<strong>!</strong></p>
</section>
</section>
<section id="performance" class="level2">
<h2 class="anchored" data-anchor-id="performance">Performance</h2>
<p>One thing that has worried me the past few days, something I actually <strong>knew</strong> was a concern with LCS, was performance. I mean <strong>speed</strong>, here. (SEE EDIT ABOVE before you continue)</p>
<p>Training requires exposing the LCS to <strong>sufficient training instances</strong> to “represent” the overall data. Here I believe, <strong>in LCS in particular</strong>, too many training instances would hinder training because of the speed of processing power needed. I truly believe <strong>better chosen training instances are more important than more training instances</strong>. Kinda contrary of what Deep Learning would have you think. Although, this belief is, right now, just that: A belief.</p>
<p>LCS on the other hand, for each training instance, require a <strong>lot</strong> of “epochs”, so s<strong>eeing the same data quite a few times</strong>. That is because <strong>after covering, the GA kicks in and that happens with choosing what best rules are available</strong>, which are <strong>evolved over time</strong> and where “best” depends on how many matches, how general but specific enough a rule is, whether a rule not only matches but also returns the correct action… The point is, ideally, you want to train your LCS on a dataset, but <strong>circle over that dataset many times</strong>. <strong>I’m talking, thousands of times ideally</strong> - for each entry.</p>
<p>The other aspect of it is, of course, choosing R as a programming language. As much as I am comfortable with it, <strong>it is a slow language</strong>, if you consider compiled alternatives and such.</p>
<p>I wanted to dive a bit into the details of what in my current (basic) implementation I could do, and so I ran the thing through “profvis” quite a few times, separate functions at separate times, then overall, with larger problems, etc.</p>
<p>One thing I do a lot, because I’m using lists for everything right now, is use “lapply()” (and al.). I have tried as much as I could to <strong>not use dependencies if I could avoid it</strong>. So much so, I believe the only actual dependency I have is the plyr package for the rbind() function, and that’s for printing stuff…</p>
<p>Not having too many dependencies is partly motivated by my end goal of producing a package, which I’d like to make “light” as much as possible.</p>
<p>Anyhow, so I use lapply() a lot, but I have also used %in% quite a few times. And in some cases, I mix both and check quite a few instances, quite a few times!</p>
<p>Matching, which happens a <strong>lot</strong>, for instance, can have an impact:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="profiling_monothread_runtimes.jpg" class="img-fluid figure-img"></p>
<figcaption>Profiling run-times of mono-thread R interpreted code with LOTS of iterations in there…</figcaption>
</figure>
</div>
</section>
<section id="nicos-trick-parallelizing" class="level2">
<h2 class="anchored" data-anchor-id="nicos-trick-parallelizing">Nico’s trick: Parallelizing!!</h2>
<p>You might know this by now: I like to parallelize stuff over my CPU cores/threads. It’s just a thing I think about when I see my processing times are… Long. Even if long is a few seconds. And here, we’re talking many iterations, which on bigger datasets/longer states means minutes.</p>
<p>(Actually, before I decided to simplify to 49 bits the states of the MNIST exercise, I was working with 784 bits states, and well, it would NOT converge after several minutes…)</p>
<p>Well, I have to keep working on this, but the cool thing is, an LCS can be pre-trained, and then re-trained.</p>
<p>So the LCS (in supervised learning setting for now) is nothing but a set of classifiers, which are rules learnt from examples. You can improve it by exposing it, simply, to <strong>more</strong> examples. <strong>Or let it run more iterations over the same examples!</strong></p>
<p>Either are valid approaches.</p>
<p>Now… What if I “sharded” my data? Say, if I have 7 CPU cores…</p>
<p>I could do one shorter run over all the data to generate a first ruleset. I could then use at the same time that pretrained LCS, and what if I trained 7 sub-LCS on 7 subsets of the data for more iterations (quite a few more epochs now, but in parallel, each on smaller data samples)?</p>
<p>What if then I <em>loop over that</em>, with some sort of “<strong>compaction</strong>” of the 7 newly re-trained sub-LCS and generate a <em>new single base LCS</em>, to <em>then re-distribute to 7 sub processes</em>.</p>
<p><em>What if I did that a few times?</em></p>
<p>I <strong>still have to think</strong> (seriously, and hard) through <em>all the implications</em> of the simple “algorithm” I just proposed above. I came up with it quite independently, mind you. And maybe it’s a very bad idea. (not showing all the training examples hinders the selection and then generalization of classifiers, for one… So <strong>maybe it’s a stupid idea</strong>… I just haven’t thought it through yet. <strong>For now I do think maybe it does in fact kinda make sense</strong>.)</p>
<p><strong>BUT, I have done it already!</strong> One version of my code allows for <strong>parallel processing like just described</strong>.</p>
<p>And well, in (quite a few) tests with the MNIST example above, for roughly the <strong>same overall runtimes</strong> (and “compaction” is costly!) <strong>I get a gain of 1-2% of correctly classified samples</strong>.</p>
<p>From 96% to 97+%. (It might sound marginal, and indeed I’m talking about a LOT more processing, but the same runtimes with marginal gains in such near-100% ranges, sounds like <strong>potentially valuable</strong>).</p>
<p>Well, indeed, I’ve done that too:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="running_parallel-v001.jpg" class="img-fluid figure-img"></p>
<figcaption>CPU-based parallel training of my LCS</figcaption>
</figure>
</div>
</section>
<section id="next-steps-packaging" class="level2">
<h2 class="anchored" data-anchor-id="next-steps-packaging">Next Steps: “Packaging”</h2>
<p>So I’ve got all the pieces of the puzzle. And it works. And I have validated some marvellous (to me) results. All in a few days.</p>
<p>Well, not a “few days”. See, I’ve coded for only a few hours maybe, but I’ve been thinking about this for a long time. And I also think it’d be unfair to say I was fast: Coding time per-se doesn’t account for waking up in the middle of the night coming up with my own design to approach the MNIST example. Waking up in the middle of the night, when I have a project like this, somehow happens more often. I have a bit of insomnia, but these projects make it worse, although they also make me more… Productive.</p>
<p>I guess what I’m saying is: <strong>coding time might not have been too many hours</strong>. But <strong>thinking time, or “obsessing” (rather) did account for much more</strong> than 4 or 5 days (in 4 to 8h/day). I mean, I have designed everything in between the days of coding, and that <strong>started long before</strong>.</p>
<p>Anyhow, to the next step: <strong>Moving from a few functions and examples to an actual Package!</strong></p>
<p>That’s what I’ll be up to when I next have time to dedicate to this.</p>
</section>
<section id="a-few-days-off" class="level2">
<h2 class="anchored" data-anchor-id="a-few-days-off">A few days off</h2>
<p>Well, that is, indeed, when I next have the time. I’ll be disconnecting for a couple of weeks during January. I simply have other personal priorities (all great).</p>
<p>So I’ll take this where I left it maybe a bit later. No matter. I have gone through half the book of packages, and I actually am more convinced than ever that this is the perfect opportunity to create a package for me.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Well, I am just so… <strong>Proud of this thing already</strong>!</p>
<p>See I had <em>only ever read about the idea until</em>… Well, basically a <em>week</em> ago. Thanks to the holiday season, and long week-end hours, <strong>I can now say I have a working LCS in R.</strong></p>
<p>Not only that:</p>
<ul>
<li><p>I know it’s <strong>already not too bad in terms of what you could expect about performance</strong>. I know (from profiling) where I could try to go <strong>RCpp</strong>. I also have ideas to run it in more “highly” parallel setups. With more cores on a machine, or… More machines! (plumbeR, here I come… Well, later though, that’s not urgent)</p></li>
<li><p>But I also know, <em>if I can “encode” a problem into a binary string for binary classification</em>, it turns out <strong>LCS are a very valid idea to consider!</strong> <strong>Just as good as a Neural Network!</strong> Heck, in some cases, <strong>better!</strong></p></li>
<li><p>I have done some testthat() already, I have several separate functions, very few (almost none) dependencies, the thing is somewhat organized… So the next step comes rather naturally.</p></li>
</ul>
<p>Anyhow, overall, <strong>I am happy to report, I do believe this (future) package can prove very valuable to the community!</strong></p>
<p>And at this stage, I <strong>already</strong> hope I can explain that in future forums - I will convince people, I’m sure of it.</p>
<p>So this is <strong>turning out to be as great a project as I had (unreasonably) imagined already a long time ago</strong>. Which, let me tell you, is <strong>very satisfying</strong> at a very personal level.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Again, if some keywords above are confusing, <a href="https://www.youtube.com/watch?v=CRge_cZ2cJc">the how of the algorithm is neatly explained in this 12’ video</a>, which I highly recommend.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>